<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>8 Ball Pool - Perks Edition</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #hud {
    display: flex;
    align-items: flex-start;
    gap: 24px;
    margin-bottom: 10px;
    color: #fff;
    font-size: 15px;
  }
  .player-info {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 16px;
    border-radius: 20px;
    background: rgba(255,255,255,0.07);
    transition: all 0.3s;
    min-width: 180px;
  }
  .player-info.active {
    background: rgba(255,255,255,0.18);
    box-shadow: 0 0 12px rgba(255,255,255,0.15);
  }
  .player-dot {
    width: 14px; height: 14px; border-radius: 50%; border: 2px solid #fff; flex-shrink: 0;
  }
  .score-row {
    display: flex; align-items: center; gap: 3px; min-height: 18px; margin-top: 2px; flex-wrap: wrap;
  }
  .score-ball {
    width: 15px; height: 15px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.3);
    display: inline-flex; align-items: center; justify-content: center;
    font-size: 7px; font-weight: bold; color: #fff;
  }
  .score-ball.stripe { background: #fff !important; color: #111; border: 2px solid var(--stripe-color, #f5d442); }
  .score-count { color: #aaa; font-size: 12px; margin-left: 2px; }
  #msgCol {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    min-width: 200px;
  }
  #message {
    color: #ffd700; font-size: 14px; min-height: 20px; text-align: center;
  }
  #canvasContainer {
    position: relative;
    border-radius: 16px;
    box-shadow: 0 0 60px rgba(0,0,0,0.5), 0 0 120px rgba(0,0,0,0.3);
  }
  canvas { display: block; border-radius: 12px; }
  #powerBarContainer {
    position: absolute; right: -40px; top: 50%; transform: translateY(-50%);
    width: 20px; height: 300px; background: rgba(0,0,0,0.5);
    border-radius: 10px; border: 2px solid rgba(255,255,255,0.2);
    overflow: hidden; display: none;
  }
  #powerBar {
    position: absolute; bottom: 0; width: 100%;
    background: linear-gradient(to top, #00ff88, #ffdd00, #ff4444);
    transition: height 0.05s;
  }

  /* ─── Perk Bar ─── */
  #perkBar {
    display: flex; align-items: center; justify-content: center;
    gap: 10px; margin-top: 8px; min-height: 52px;
  }
  .perk-card {
    width: 90px; height: 46px;
    border-radius: 10px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    cursor: pointer;
    border: 2px solid rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.06);
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  .perk-card:hover {
    transform: scale(1.08);
    border-color: rgba(255,255,255,0.4);
    box-shadow: 0 0 16px rgba(255,255,255,0.15);
  }
  .perk-card .perk-icon { font-size: 18px; line-height: 1; }
  .perk-card .perk-name { font-size: 9px; color: #ccc; margin-top: 2px; text-transform: uppercase; letter-spacing: 0.5px; }
  .perk-card.active-perk { border-color: #ffd700; box-shadow: 0 0 20px rgba(255,215,0,0.4); }
  .perk-card.active-perk::before {
    content: 'ACTIVE'; position: absolute; top: 2px; right: 4px;
    font-size: 6px; color: #ffd700; font-weight: bold; letter-spacing: 1px;
  }
  .perk-card[data-perk="bigPockets"] { background: linear-gradient(135deg, rgba(0,200,100,0.2), rgba(0,100,50,0.1)); }
  .perk-card[data-perk="laser"] { background: linear-gradient(135deg, rgba(255,50,50,0.2), rgba(150,0,0,0.1)); }
  .perk-card[data-perk="powerSurge"] { background: linear-gradient(135deg, rgba(50,100,255,0.2), rgba(0,50,200,0.1)); }
  .perk-card[data-perk="earthquake"] { background: linear-gradient(135deg, rgba(200,150,0,0.2), rgba(100,80,0,0.1)); }
  .perk-card[data-perk="freeze"] { background: linear-gradient(135deg, rgba(100,200,255,0.2), rgba(50,100,200,0.1)); }
  .perk-card[data-perk="ballInHand"] { background: linear-gradient(135deg, rgba(200,100,255,0.2), rgba(100,50,200,0.1)); }
  .perk-label { color: #888; font-size: 11px; white-space: nowrap; }
  .perk-empty { color: #444; font-size: 11px; font-style: italic; }

  /* ─── Roulette Spinner ─── */
  #roulette {
    position: fixed; inset: 0;
    display: none; align-items: center; justify-content: center;
    z-index: 200;
    background: rgba(0,0,0,0.5);
  }
  #roulette.show { display: flex; }
  #rouletteBox {
    background: linear-gradient(135deg, #16213e, #0f3460);
    padding: 24px 36px;
    border-radius: 18px;
    text-align: center;
    color: #fff;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    min-width: 260px;
  }
  #rouletteBox h3 { font-size: 14px; color: #aaa; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 2px; }
  #rouletteSlot {
    font-size: 48px; line-height: 1.2; min-height: 64px;
    display: flex; align-items: center; justify-content: center;
  }
  #rouletteName {
    font-size: 16px; color: #ffd700; margin-top: 8px; font-weight: bold;
    min-height: 24px;
  }
  #rouletteDesc {
    font-size: 12px; color: #888; margin-top: 4px; min-height: 18px;
  }

  /* ─── Overlay ─── */
  #overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.75);
    display: flex; align-items: center; justify-content: center;
    z-index: 100;
  }
  #overlay.hidden { display: none; }
  .modal {
    background: linear-gradient(135deg, #16213e, #0f3460);
    padding: 40px 50px; border-radius: 20px; text-align: center;
    color: #fff; box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
  .modal h1 { font-size: 36px; margin-bottom: 6px; }
  .modal .subtitle { color: #e94560; font-size: 14px; margin-bottom: 4px; }
  .modal p { color: #aaa; margin-bottom: 24px; font-size: 14px; }
  .btn {
    background: linear-gradient(135deg, #e94560, #c23152);
    color: #fff; border: none; padding: 14px 40px;
    font-size: 18px; border-radius: 30px; cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .btn:hover { transform: scale(1.05); box-shadow: 0 6px 25px rgba(233,69,96,0.5); }
  #instructions { color: #555; font-size: 11px; margin-top: 4px; }
</style>
</head>
<body>

<div id="hud">
  <div class="player-info active" id="p1info">
    <div class="player-dot" id="p1dot"></div>
    <div>
      <span id="p1label">Player 1</span>
      <div class="score-row" id="p1score"></div>
    </div>
  </div>
  <div id="msgCol">
    <div id="message">Break the rack!</div>
  </div>
  <div class="player-info" id="p2info">
    <div>
      <span id="p2label">Player 2</span>
      <div class="score-row" id="p2score"></div>
    </div>
    <div class="player-dot" id="p2dot"></div>
  </div>
</div>

<div id="canvasContainer">
  <canvas id="game"></canvas>
  <div id="powerBarContainer"><div id="powerBar"></div></div>
</div>

<div id="perkBar">
  <span class="perk-label" id="perkOwner"></span>
  <div id="perkSlots"></div>
</div>

<div id="instructions">Click & drag to aim · Pull back for power · Release to shoot · Click a perk card to activate before shooting</div>

<div id="roulette">
  <div id="rouletteBox">
    <h3>Perk Awarded!</h3>
    <div id="rouletteSlot"></div>
    <div id="rouletteName"></div>
    <div id="rouletteDesc"></div>
  </div>
</div>

<div id="overlay">
  <div class="modal">
    <h1>8 Ball Pool</h1>
    <div class="subtitle">Perks Edition</div>
    <p>Pocket balls to earn perk cards. Use them wisely!</p>
    <button class="btn" id="startBtn">Play</button>
  </div>
</div>

<script>
(() => {
  // ─── Constants ───
  const TABLE_W = 900, TABLE_H = 480;
  const CUSHION = 36;
  const BALL_R = 11;
  const POCKET_R = 20;
  const FRICTION = 0.985;
  const MIN_VEL = 0.08;
  const MAX_POWER = 22;
  const CUE_LENGTH = 200;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = TABLE_W + CUSHION * 2;
  canvas.height = TABLE_H + CUSHION * 2;

  const msgEl = document.getElementById('message');
  const overlayEl = document.getElementById('overlay');
  const powerBarContainer = document.getElementById('powerBarContainer');
  const powerBarEl = document.getElementById('powerBar');
  const p1info = document.getElementById('p1info');
  const p2info = document.getElementById('p2info');
  const p1dot = document.getElementById('p1dot');
  const p2dot = document.getElementById('p2dot');
  const p1label = document.getElementById('p1label');
  const p2label = document.getElementById('p2label');
  const p1score = document.getElementById('p1score');
  const p2score = document.getElementById('p2score');
  const perkBarEl = document.getElementById('perkBar');
  const perkSlotsEl = document.getElementById('perkSlots');
  const perkOwnerEl = document.getElementById('perkOwner');
  const rouletteEl = document.getElementById('roulette');
  const rouletteSlot = document.getElementById('rouletteSlot');
  const rouletteName = document.getElementById('rouletteName');
  const rouletteDesc = document.getElementById('rouletteDesc');

  const BALL_COLORS = [
    '#ffffff','#f5d442','#2255cc','#cc2222','#6622aa','#ee7722','#228833','#882222',
    '#111111','#f5d442','#2255cc','#cc2222','#6622aa','#ee7722','#228833','#882222',
  ];

  const POCKETS = [
    { x: CUSHION + 2, y: CUSHION + 2 },
    { x: CUSHION + TABLE_W / 2, y: CUSHION - 2 },
    { x: CUSHION + TABLE_W - 2, y: CUSHION + 2 },
    { x: CUSHION + 2, y: CUSHION + TABLE_H - 2 },
    { x: CUSHION + TABLE_W / 2, y: CUSHION + TABLE_H + 2 },
    { x: CUSHION + TABLE_W - 2, y: CUSHION + TABLE_H - 2 },
  ];

  // ─── Perk Definitions ───
  const PERKS = {
    bigPockets:  { icon: '\u{1F573}\uFE0F', name: 'Big Pockets',   desc: 'Pockets grow 50% bigger for this shot',        color: '#00c864' },
    laser:       { icon: '\u{1F3AF}',       name: 'Laser Aim',     desc: 'See where the target ball will go',             color: '#ff3333' },
    powerSurge:  { icon: '\u26A1',          name: 'Power Surge',   desc: '2x maximum shot power',                         color: '#3366ff' },
    earthquake:  { icon: '\u{1F30D}',       name: 'Earthquake',    desc: 'Randomly nudge all opponent balls after shot',   color: '#ccaa00' },
    freeze:      { icon: '\u2744\uFE0F',    name: 'Freeze',        desc: "Opponent's next shot is capped at 40% power",    color: '#66ccff' },
    ballInHand:  { icon: '\u{1F52E}',       name: 'Ball In Hand',  desc: 'Place the cue ball anywhere on the table',       color: '#cc66ff' },
  };
  const PERK_KEYS = Object.keys(PERKS);

  // ─── State ───
  let balls = [];
  let currentPlayer = 1;
  let playerTypes = { 1: null, 2: null };
  let pocketedThisTurn = [];
  let cueBallPocketed = false;
  let firstContactBall = null;
  let gamePhase = 'menu'; // menu|aiming|shooting|placing|placingFree|roulette|gameover
  let aimStart = null;
  let mousePos = { x: 0, y: 0 };
  let placingCue = false;
  let breakShot = true;
  let winner = null;

  // Perk state
  let playerPerks = { 1: [], 2: [] }; // arrays of perk keys, max 3
  let activePerk = null; // perk key active for current shot
  let frozenPlayer = 0; // player # who is frozen (0 = none)
  let particles = [];
  let screenShake = 0;
  let pocketSizeBonus = 0; // extra pocket radius
  let trailPoints = []; // for power surge trail

  // ─── Ball Factory ───
  function makeBall(id, x, y) {
    return { id, x, y, vx: 0, vy: 0, pocketed: false };
  }

  function rackBalls() {
    balls = [];
    const cx = CUSHION + TABLE_W * 0.73;
    const cy = CUSHION + TABLE_H / 2;
    const d = BALL_R * 2 + 1;
    const sin60 = Math.sin(Math.PI / 3);
    const order = [1, 9, 2, 10, 8, 11, 3, 12, 6, 14, 4, 13, 7, 15, 5];
    let idx = 0;
    for (let row = 0; row < 5; row++) {
      for (let col = 0; col <= row; col++) {
        const bx = cx + row * d * sin60;
        const by = cy + (col - row / 2) * d;
        balls.push(makeBall(order[idx], bx, by));
        idx++;
      }
    }
    balls.unshift(makeBall(0, CUSHION + TABLE_W * 0.25, cy));
  }

  // ─── Pocket detection ───
  function currentPocketR() { return POCKET_R + pocketSizeBonus; }

  function isInPocket(b) {
    const pr = currentPocketR();
    for (const p of POCKETS) {
      const dx = b.x - p.x, dy = b.y - p.y;
      if (dx * dx + dy * dy < (pr + 2) * (pr + 2)) return true;
    }
    return false;
  }

  // ─── Physics ───
  function moving() {
    return balls.some(b => !b.pocketed && (Math.abs(b.vx) > MIN_VEL || Math.abs(b.vy) > MIN_VEL));
  }

  function stepPhysics() {
    const active = balls.filter(b => !b.pocketed);
    for (const b of active) {
      b.x += b.vx;
      b.y += b.vy;
      b.vx *= FRICTION;
      b.vy *= FRICTION;
      if (Math.abs(b.vx) < MIN_VEL) b.vx = 0;
      if (Math.abs(b.vy) < MIN_VEL) b.vy = 0;

      const left = CUSHION + BALL_R, right = CUSHION + TABLE_W - BALL_R;
      const top = CUSHION + BALL_R, bottom = CUSHION + TABLE_H - BALL_R;
      if (b.x < left)  { b.x = left;  b.vx = -b.vx * 0.8; }
      if (b.x > right) { b.x = right; b.vx = -b.vx * 0.8; }
      if (b.y < top)    { b.y = top;    b.vy = -b.vy * 0.8; }
      if (b.y > bottom) { b.y = bottom; b.vy = -b.vy * 0.8; }

      if (isInPocket(b)) {
        b.pocketed = true;
        b.vx = b.vy = 0;
        if (b.id === 0) cueBallPocketed = true;
        else {
          pocketedThisTurn.push(b.id);
          // pocket particles
          spawnPocketParticles(b.x, b.y, BALL_COLORS[b.id]);
        }
      }
    }

    // Power surge trail
    if (activePerk === 'powerSurge') {
      const cue = balls.find(b => b.id === 0);
      if (!cue.pocketed && (Math.abs(cue.vx) > 0.5 || Math.abs(cue.vy) > 0.5)) {
        trailPoints.push({ x: cue.x, y: cue.y, life: 30 });
      }
    }

    // Ball-ball collisions
    for (let i = 0; i < active.length; i++) {
      for (let j = i + 1; j < active.length; j++) {
        const a = active[i], b = active[j];
        if (a.pocketed || b.pocketed) continue;
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minD = BALL_R * 2;
        if (dist < minD && dist > 0) {
          if (firstContactBall === null) {
            if (a.id === 0) firstContactBall = b.id;
            else if (b.id === 0) firstContactBall = a.id;
          }
          const nx = dx / dist, ny = dy / dist;
          const overlap = minD - dist;
          a.x -= nx * overlap / 2; a.y -= ny * overlap / 2;
          b.x += nx * overlap / 2; b.y += ny * overlap / 2;
          const dvx = a.vx - b.vx, dvy = a.vy - b.vy;
          const dot = dvx * nx + dvy * ny;
          if (dot > 0) {
            a.vx -= dot * nx * 0.96; a.vy -= dot * ny * 0.96;
            b.vx += dot * nx * 0.96; b.vy += dot * ny * 0.96;
          }
          // collision sparks
          if (dot > 2) {
            for (let k = 0; k < 4; k++) {
              const ang = Math.random() * Math.PI * 2;
              particles.push({
                x: (a.x + b.x) / 2, y: (a.y + b.y) / 2,
                vx: Math.cos(ang) * (1 + Math.random() * 2),
                vy: Math.sin(ang) * (1 + Math.random() * 2),
                life: 15 + Math.random() * 10,
                color: '#fff', size: 2
              });
            }
          }
        }
      }
    }
  }

  // ─── Particles ───
  function spawnPocketParticles(x, y, color) {
    for (let i = 0; i < 16; i++) {
      const ang = Math.random() * Math.PI * 2;
      const sp = 1 + Math.random() * 3;
      particles.push({
        x, y,
        vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
        life: 25 + Math.random() * 20,
        color, size: 2 + Math.random() * 2
      });
    }
  }

  function spawnEarthquakeParticles() {
    for (const b of balls.filter(b2 => !b2.pocketed && b2.id !== 0)) {
      for (let i = 0; i < 6; i++) {
        const ang = Math.random() * Math.PI * 2;
        particles.push({
          x: b.x, y: b.y,
          vx: Math.cos(ang) * (1 + Math.random()), vy: Math.sin(ang) * (1 + Math.random()),
          life: 15 + Math.random() * 10,
          color: '#ccaa00', size: 2
        });
      }
    }
  }

  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.95; p.vy *= 0.95;
      p.life--;
      if (p.life <= 0) particles.splice(i, 1);
    }
    for (let i = trailPoints.length - 1; i >= 0; i--) {
      trailPoints[i].life--;
      if (trailPoints[i].life <= 0) trailPoints.splice(i, 1);
    }
    if (screenShake > 0) screenShake -= 0.5;
  }

  // ─── Laser Aim helper ───
  function findFirstHitBall(cx, cy, nx, ny) {
    let closestT = Infinity, hitBall = null;
    for (const b of balls) {
      if (b.pocketed || b.id === 0) continue;
      const dx = b.x - cx, dy = b.y - cy;
      const proj = dx * nx + dy * ny;
      if (proj < 0) continue;
      const perpSq = (dx * dx + dy * dy) - proj * proj;
      const minD = BALL_R * 2;
      if (perpSq < minD * minD) {
        const t = proj - Math.sqrt(minD * minD - perpSq);
        if (t > 0 && t < closestT) { closestT = t; hitBall = b; }
      }
    }
    return hitBall ? { ball: hitBall, t: closestT } : null;
  }

  // ─── Turn resolution ───
  function resolveTurn() {
    let foul = false, switchTurn = true, msg = '';
    let curType = playerTypes[currentPlayer];

    if (cueBallPocketed) { foul = true; msg = 'Foul! Cue ball pocketed.'; }
    if (!foul && firstContactBall === null && !cueBallPocketed) { foul = true; msg = 'Foul! No ball contacted.'; }

    if (!foul && firstContactBall !== null && curType) {
      const fcId = firstContactBall;
      const isSolid = fcId >= 1 && fcId <= 7, isStripe = fcId >= 9 && fcId <= 15, is8 = fcId === 8;
      const remaining = balls.filter(b => !b.pocketed && b.id !== 0 && b.id !== 8);
      const myRemaining = remaining.filter(b => curType === 'solids' ? (b.id >= 1 && b.id <= 7) : (b.id >= 9 && b.id <= 15));
      if (myRemaining.length === 0) {
        if (!is8) { foul = true; msg = 'Foul! Must hit the 8-ball.'; }
      } else {
        if (curType === 'solids' && !isSolid) { foul = true; msg = 'Foul! Hit wrong group.'; }
        if (curType === 'stripes' && !isStripe) { foul = true; msg = 'Foul! Hit wrong group.'; }
      }
    }

    if (!breakShot && !playerTypes[1] && pocketedThisTurn.length > 0) {
      const first = pocketedThisTurn[0];
      if (first !== 8) {
        if (first >= 1 && first <= 7) {
          playerTypes[currentPlayer] = 'solids';
          playerTypes[currentPlayer === 1 ? 2 : 1] = 'stripes';
        } else {
          playerTypes[currentPlayer] = 'stripes';
          playerTypes[currentPlayer === 1 ? 2 : 1] = 'solids';
        }
        msg = `Player ${currentPlayer} is ${playerTypes[currentPlayer]}!`;
        curType = playerTypes[currentPlayer];
        updateHUD();
      }
    }

    const eightPocketed = pocketedThisTurn.includes(8);
    if (eightPocketed) {
      const remaining = balls.filter(b => !b.pocketed && b.id !== 0 && b.id !== 8);
      const myRemaining = curType
        ? remaining.filter(b => curType === 'solids' ? (b.id >= 1 && b.id <= 7) : (b.id >= 9 && b.id <= 15))
        : [1];
      if (myRemaining.length === 0 && !foul && curType) {
        winner = currentPlayer;
        gamePhase = 'gameover';
        showOverlay(`Player ${currentPlayer} wins!`, 'Play Again');
        return;
      } else {
        winner = currentPlayer === 1 ? 2 : 1;
        gamePhase = 'gameover';
        showOverlay(`Player ${winner} wins!`, 'Play Again');
        return;
      }
    }

    // Earthquake perk: nudge opponent balls
    if (activePerk === 'earthquake' && !foul) {
      const oppType = playerTypes[currentPlayer === 1 ? 2 : 1];
      const targets = balls.filter(b => {
        if (b.pocketed || b.id === 0 || b.id === 8) return false;
        if (!oppType) return b.id !== 0;
        return oppType === 'solids' ? (b.id >= 1 && b.id <= 7) : (b.id >= 9 && b.id <= 15);
      });
      for (const b of targets) {
        b.x += (Math.random() - 0.5) * 40;
        b.y += (Math.random() - 0.5) * 40;
        b.x = Math.max(CUSHION + BALL_R, Math.min(b.x, CUSHION + TABLE_W - BALL_R));
        b.y = Math.max(CUSHION + BALL_R, Math.min(b.y, CUSHION + TABLE_H - BALL_R));
      }
      screenShake = 12;
      spawnEarthquakeParticles();
      if (!msg) msg = 'Earthquake! Opponent balls shifted!';
    }

    // Freeze perk: freeze opponent
    if (activePerk === 'freeze' && !foul) {
      frozenPlayer = currentPlayer === 1 ? 2 : 1;
      if (!msg) msg = `Player ${frozenPlayer} is frozen! 40% power next shot.`;
    }

    // Award perks for pocketed balls (not 8-ball, not on break for balance)
    const perksToAward = pocketedThisTurn.filter(id => id !== 8).length;

    if (!foul && pocketedThisTurn.length > 0 && curType) {
      const myPocketed = pocketedThisTurn.filter(id => {
        if (curType === 'solids') return id >= 1 && id <= 7;
        if (curType === 'stripes') return id >= 9 && id <= 15;
        return false;
      });
      if (myPocketed.length > 0) {
        switchTurn = false;
        if (!msg) msg = `Player ${currentPlayer} continues!`;
      }
    }

    if (breakShot && pocketedThisTurn.length > 0 && !foul) {
      switchTurn = false;
      if (!msg) msg = `Nice break! Player ${currentPlayer} continues.`;
    }

    // Reset perk effects
    pocketSizeBonus = 0;
    const usedPerk = activePerk;
    activePerk = null;
    trailPoints = [];

    if (foul) {
      switchTurn = true;
      respawnCueBall();
      placingCue = true;
      gamePhase = 'placing';
    }

    if (switchTurn && !foul) {
      currentPlayer = currentPlayer === 1 ? 2 : 1;
    } else if (foul) {
      currentPlayer = currentPlayer === 1 ? 2 : 1;
      msg += ` Player ${currentPlayer}'s turn — click the highlighted zone to place the cue ball.`;
    }

    breakShot = false;
    if (!msg) msg = `Player ${currentPlayer}'s turn`;
    msgEl.textContent = msg;
    updateHUD();
    renderPerkBar();

    // Award perk via roulette if earned (after a short delay)
    const awardTo = switchTurn ? (currentPlayer === 1 ? 2 : 1) : currentPlayer;
    if (perksToAward > 0 && !foul && playerPerks[awardTo].length < 3) {
      const count = Math.min(perksToAward, 3 - playerPerks[awardTo].length);
      let awarded = 0;
      gamePhase = 'roulette'; // prevent game loop from re-calling resolveTurn
      function awardNext() {
        if (awarded >= count) {
          if (!placingCue) gamePhase = 'aiming';
          renderPerkBar();
          return;
        }
        showRoulette(awardTo, () => {
          awarded++;
          setTimeout(awardNext, 200);
        });
      }
      setTimeout(awardNext, 400);
      return;
    }

    if (!placingCue) gamePhase = 'aiming';
  }

  function respawnCueBall() {
    const cue = balls.find(b => b.id === 0);
    cue.pocketed = true; // keep hidden until placed
    cue.x = -100; cue.y = -100; // off-screen
    cue.vx = cue.vy = 0;
  }

  // ─── Roulette ───
  function showRoulette(playerId, callback) {
    gamePhase = 'roulette';
    rouletteEl.classList.add('show');
    let ticks = 0;
    const totalTicks = 18;
    const finalPerk = PERK_KEYS[Math.floor(Math.random() * PERK_KEYS.length)];

    function tick() {
      ticks++;
      const randomKey = ticks < totalTicks
        ? PERK_KEYS[Math.floor(Math.random() * PERK_KEYS.length)]
        : finalPerk;
      const perk = PERKS[randomKey];
      rouletteSlot.textContent = perk.icon;
      rouletteName.textContent = perk.name;
      rouletteDesc.textContent = ticks >= totalTicks ? perk.desc : '';
      rouletteName.style.color = perk.color;

      if (ticks < totalTicks) {
        setTimeout(tick, 60 + ticks * 12);
      } else {
        // Award it
        playerPerks[playerId].push(finalPerk);
        setTimeout(() => {
          rouletteEl.classList.remove('show');
          callback();
        }, 1000);
      }
    }
    tick();
  }

  // ─── Overlay ───
  function showOverlay(title, btnText) {
    overlayEl.classList.remove('hidden');
    overlayEl.querySelector('h1').textContent = title;
    overlayEl.querySelector('.btn').textContent = btnText;
  }

  // ─── HUD ───
  function updateHUD() {
    p1info.classList.toggle('active', currentPlayer === 1);
    p2info.classList.toggle('active', currentPlayer === 2);
    const t1 = playerTypes[1], t2 = playerTypes[2];
    p1label.textContent = 'Player 1' + (t1 ? ` (${t1})` : '');
    p2label.textContent = 'Player 2' + (t2 ? ` (${t2})` : '');
    if (t1 === 'solids') { p1dot.style.background = '#f5d442'; p1dot.style.borderColor = '#f5d442'; }
    else if (t1 === 'stripes') { p1dot.style.background = 'transparent'; p1dot.style.borderColor = '#f5d442'; }
    else { p1dot.style.background = '#555'; p1dot.style.borderColor = '#fff'; }
    if (t2 === 'solids') { p2dot.style.background = '#f5d442'; p2dot.style.borderColor = '#f5d442'; }
    else if (t2 === 'stripes') { p2dot.style.background = 'transparent'; p2dot.style.borderColor = '#f5d442'; }
    else { p2dot.style.background = '#555'; p2dot.style.borderColor = '#fff'; }
    updateScoreDisplay();
  }

  function updateScoreDisplay() {
    const pocketed = balls.filter(b => b.pocketed && b.id !== 0);
    function renderBalls(container, type) {
      container.innerHTML = '';
      if (!type) return;
      const mine = pocketed.filter(b => {
        if (type === 'solids') return b.id >= 1 && b.id <= 7;
        if (type === 'stripes') return b.id >= 9 && b.id <= 15;
        return false;
      }).sort((a, b) => a.id - b.id);
      for (const b of mine) {
        const el = document.createElement('div');
        el.className = 'score-ball' + (b.id >= 9 ? ' stripe' : '');
        if (b.id >= 9) el.style.setProperty('--stripe-color', BALL_COLORS[b.id]);
        else el.style.backgroundColor = BALL_COLORS[b.id];
        el.textContent = b.id;
        container.appendChild(el);
      }
      if (mine.length > 0) {
        const c = document.createElement('span');
        c.className = 'score-count';
        c.textContent = `${mine.length}/7`;
        container.appendChild(c);
      }
    }
    renderBalls(p1score, playerTypes[1]);
    renderBalls(p2score, playerTypes[2]);
  }

  // ─── Perk Bar ───
  function renderPerkBar() {
    const perks = playerPerks[currentPlayer];
    perkOwnerEl.textContent = `P${currentPlayer} Perks:`;
    perkSlotsEl.innerHTML = '';
    perkSlotsEl.style.display = 'flex';
    perkSlotsEl.style.gap = '8px';

    if (perks.length === 0) {
      const empty = document.createElement('span');
      empty.className = 'perk-empty';
      empty.textContent = 'Pocket a ball to earn perks';
      perkSlotsEl.appendChild(empty);
      return;
    }

    perks.forEach((key, i) => {
      const perk = PERKS[key];
      const card = document.createElement('div');
      card.className = 'perk-card' + (activePerk === key && i === perks.indexOf(key) ? ' active-perk' : '');
      card.dataset.perk = key;
      card.title = perk.desc;
      card.innerHTML = `<span class="perk-icon">${perk.icon}</span><span class="perk-name">${perk.name}</span>`;
      card.addEventListener('click', () => {
        if (gamePhase !== 'aiming' && gamePhase !== 'placingFree') return;
        if (activePerk === key) {
          // Deactivate
          activePerk = null;
          pocketSizeBonus = 0;
          // If ball-in-hand was active, cancel free placement
          if (gamePhase === 'placingFree') {
            gamePhase = 'aiming';
            // restore the perk back
          }
          renderPerkBar();
          msgEl.textContent = 'Perk deactivated.';
          return;
        }
        activePerk = key;
        playerPerks[currentPlayer].splice(i, 1);

        // Immediate perk effects
        if (key === 'bigPockets') {
          pocketSizeBonus = POCKET_R * 0.5;
          msgEl.textContent = 'Big Pockets active! Pockets are huge!';
        } else if (key === 'laser') {
          msgEl.textContent = 'Laser Aim active! Trajectory shown.';
        } else if (key === 'powerSurge') {
          msgEl.textContent = 'Power Surge active! 2x POWER!';
        } else if (key === 'earthquake') {
          msgEl.textContent = 'Earthquake loaded! Balls shift after shot.';
        } else if (key === 'freeze') {
          msgEl.textContent = 'Freeze loaded! Opponent slowed next turn.';
        } else if (key === 'ballInHand') {
          msgEl.textContent = 'Ball In Hand! Click anywhere to place cue ball.';
          gamePhase = 'placingFree';
        }
        renderPerkBar();
      });
      perkSlotsEl.appendChild(card);
    });
  }

  // ─── Drawing ───
  function draw() {
    ctx.save();

    // Screen shake
    if (screenShake > 0) {
      ctx.translate(
        (Math.random() - 0.5) * screenShake,
        (Math.random() - 0.5) * screenShake
      );
    }

    ctx.clearRect(-20, -20, canvas.width + 40, canvas.height + 40);

    // Outer frame
    ctx.fillStyle = '#3b2212';
    ctx.beginPath();
    ctx.roundRect(0, 0, canvas.width, canvas.height, 14);
    ctx.fill();

    // Inner felt
    ctx.fillStyle = '#0a6e3a';
    ctx.fillRect(CUSHION, CUSHION, TABLE_W, TABLE_H);

    // Freeze effect on felt
    if (frozenPlayer === currentPlayer) {
      ctx.fillStyle = 'rgba(100,200,255,0.08)';
      ctx.fillRect(CUSHION, CUSHION, TABLE_W, TABLE_H);
    }

    // Cushion shading
    ctx.fillStyle = '#085c30';
    ctx.fillRect(CUSHION, CUSHION, TABLE_W, 4);
    ctx.fillRect(CUSHION, CUSHION + TABLE_H - 4, TABLE_W, 4);
    ctx.fillRect(CUSHION, CUSHION, 4, TABLE_H);
    ctx.fillRect(CUSHION + TABLE_W - 4, CUSHION, 4, TABLE_H);

    // Head string line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.setLineDash([6, 6]);
    const hx = CUSHION + TABLE_W * 0.25;
    ctx.beginPath();
    ctx.moveTo(hx, CUSHION);
    ctx.lineTo(hx, CUSHION + TABLE_H);
    ctx.stroke();
    ctx.setLineDash([]);

    // Pockets
    const pr = currentPocketR();
    for (const p of POCKETS) {
      // Glow if big pockets active
      if (pocketSizeBonus > 0) {
        ctx.fillStyle = 'rgba(0,200,100,0.15)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, pr + 8, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(p.x, p.y, pr, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(p.x, p.y, pr - 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Power surge trail
    for (const tp of trailPoints) {
      const alpha = tp.life / 30;
      ctx.fillStyle = `rgba(50,100,255,${alpha * 0.5})`;
      ctx.beginPath();
      ctx.arc(tp.x, tp.y, BALL_R * alpha, 0, Math.PI * 2);
      ctx.fill();
    }

    // Balls
    for (const b of balls) {
      if (b.pocketed) continue;
      drawBall(b);
    }

    // Particles
    for (const p of particles) {
      const alpha = p.life / 40;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Aiming line & cue
    if ((gamePhase === 'aiming' || gamePhase === 'placingFree') && aimStart) {
      const cue = balls.find(b => b.id === 0);
      const dx = aimStart.x - mousePos.x;
      const dy = aimStart.y - mousePos.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 5) {
        const nx = dx / dist, ny = dy / dist;

        // Laser Aim perk: show target ball trajectory
        if (activePerk === 'laser') {
          const hit = findFirstHitBall(cue.x, cue.y, nx, ny);
          if (hit) {
            // Ghost cue ball at contact point
            const contactX = cue.x + nx * hit.t;
            const contactY = cue.y + ny * hit.t;
            ctx.strokeStyle = 'rgba(255,50,50,0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 5]);
            ctx.beginPath();
            ctx.moveTo(cue.x, cue.y);
            ctx.lineTo(contactX, contactY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Ghost cue position
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(contactX, contactY, BALL_R, 0, Math.PI * 2);
            ctx.stroke();

            // Target ball direction
            const tdx = hit.ball.x - contactX;
            const tdy = hit.ball.y - contactY;
            const td = Math.sqrt(tdx * tdx + tdy * tdy);
            if (td > 0) {
              const tnx = tdx / td, tny = tdy / td;
              ctx.strokeStyle = 'rgba(255,50,50,0.6)';
              ctx.lineWidth = 2;
              ctx.setLineDash([4, 6]);
              ctx.beginPath();
              ctx.moveTo(hit.ball.x, hit.ball.y);
              ctx.lineTo(hit.ball.x + tnx * 200, hit.ball.y + tny * 200);
              ctx.stroke();
              ctx.setLineDash([]);

              // Cue ball deflection
              const cueDeflectX = contactX + (nx - tnx * (nx * tnx + ny * tny)) ;
              const cueDeflectY = contactY + (ny - tny * (nx * tnx + ny * tny));
              const cdLen = Math.sqrt(cueDeflectX * cueDeflectX + cueDeflectY * cueDeflectY);
              // Not rendering cue deflection to keep it simpler
            }
          }
        }

        // Standard aim dotted line
        ctx.strokeStyle = activePerk === 'laser' ? 'rgba(255,50,50,0.3)' : 'rgba(255,255,255,0.3)';
        ctx.setLineDash([4, 8]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cue.x, cue.y);
        ctx.lineTo(cue.x + nx * 500, cue.y + ny * 500);
        ctx.stroke();
        ctx.setLineDash([]);

        // Cue stick
        const power = Math.min(dist, 200);
        const pullBack = power * 0.6;
        const cueStartX = cue.x - nx * (BALL_R + 8 + pullBack);
        const cueStartY = cue.y - ny * (BALL_R + 8 + pullBack);
        const cueEndX = cueStartX - nx * CUE_LENGTH;
        const cueEndY = cueStartY - ny * CUE_LENGTH;

        // Cue shadow
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(cueStartX + 2, cueStartY + 2);
        ctx.lineTo(cueEndX + 2, cueEndY + 2);
        ctx.stroke();

        // Cue body
        let grad;
        if (activePerk === 'powerSurge') {
          grad = ctx.createLinearGradient(cueStartX, cueStartY, cueEndX, cueEndY);
          grad.addColorStop(0, '#aaddff');
          grad.addColorStop(0.05, '#ffffff');
          grad.addColorStop(0.15, '#3366ff');
          grad.addColorStop(0.5, '#0033cc');
          grad.addColorStop(1, '#001166');
          // Electric glow
          ctx.strokeStyle = 'rgba(50,100,255,0.3)';
          ctx.lineWidth = 14;
          ctx.beginPath();
          ctx.moveTo(cueStartX, cueStartY);
          ctx.lineTo(cueEndX, cueEndY);
          ctx.stroke();
        } else {
          grad = ctx.createLinearGradient(cueStartX, cueStartY, cueEndX, cueEndY);
          grad.addColorStop(0, '#f5e6c8');
          grad.addColorStop(0.05, '#fff');
          grad.addColorStop(0.1, '#d4a54a');
          grad.addColorStop(1, '#3d2b1f');
        }
        ctx.strokeStyle = grad;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(cueStartX, cueStartY);
        ctx.lineTo(cueEndX, cueEndY);
        ctx.stroke();
        ctx.lineCap = 'butt';

        // Power surge sparks on cue tip
        if (activePerk === 'powerSurge' && Math.random() < 0.4) {
          const ang = Math.random() * Math.PI * 2;
          particles.push({
            x: cueStartX, y: cueStartY,
            vx: Math.cos(ang) * 2, vy: Math.sin(ang) * 2,
            life: 10 + Math.random() * 8,
            color: '#66aaff', size: 2
          });
        }
      }
    }

    // Placing cue ball indicators
    if (gamePhase === 'placing') {
      // Highlight valid placement zone (behind head string)
      const zoneX = CUSHION;
      const zoneW = TABLE_W * 0.25;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(zoneX, CUSHION, zoneW, TABLE_H);
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.strokeRect(zoneX + 1, CUSHION + 1, zoneW - 2, TABLE_H - 2);
      ctx.setLineDash([]);

      // "CLICK HERE" label
      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
      ctx.fillStyle = `rgba(255,255,255,${0.15 + pulse * 0.15})`;
      ctx.font = 'bold 16px Segoe UI';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('CLICK TO PLACE', zoneX + zoneW / 2, CUSHION + TABLE_H / 2 - 20);
      ctx.fillText('CUE BALL', zoneX + zoneW / 2, CUSHION + TABLE_H / 2 + 4);

      // Ghost cue ball following mouse, clamped to zone
      let gx = Math.max(CUSHION + BALL_R, Math.min(mousePos.x, CUSHION + zoneW));
      let gy = Math.max(CUSHION + BALL_R, Math.min(mousePos.y, CUSHION + TABLE_H - BALL_R));
      const overlapPlace = balls.some(b => b.id !== 0 && !b.pocketed && Math.hypot(b.x - gx, b.y - gy) < BALL_R * 2.5);
      ctx.globalAlpha = overlapPlace ? 0.25 : 0.6;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(gx, gy, BALL_R, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = overlapPlace ? '#ff4444' : '#ffffff';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(gx, gy, BALL_R + 3, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (gamePhase === 'placingFree') {
      // Highlight full table
      ctx.fillStyle = 'rgba(200,100,255,0.06)';
      ctx.fillRect(CUSHION, CUSHION, TABLE_W, TABLE_H);
      ctx.strokeStyle = 'rgba(200,100,255,0.25)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.strokeRect(CUSHION + 1, CUSHION + 1, TABLE_W - 2, TABLE_H - 2);
      ctx.setLineDash([]);

      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
      ctx.fillStyle = `rgba(200,100,255,${0.15 + pulse * 0.15})`;
      ctx.font = 'bold 16px Segoe UI';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('CLICK ANYWHERE TO PLACE CUE BALL', CUSHION + TABLE_W / 2, CUSHION + TABLE_H / 2);

      // Ghost cue ball following mouse
      let gx = Math.max(CUSHION + BALL_R, Math.min(mousePos.x, CUSHION + TABLE_W - BALL_R));
      let gy = Math.max(CUSHION + BALL_R, Math.min(mousePos.y, CUSHION + TABLE_H - BALL_R));
      const overlapFree = balls.some(b => b.id !== 0 && !b.pocketed && Math.hypot(b.x - gx, b.y - gy) < BALL_R * 2.5);
      ctx.globalAlpha = overlapFree ? 0.25 : 0.6;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(gx, gy, BALL_R, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = overlapFree ? '#ff4444' : '#cc66ff';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(gx, gy, BALL_R + 3, 0, Math.PI * 2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Frozen indicator
    if (frozenPlayer === currentPlayer && (gamePhase === 'aiming' || gamePhase === 'placingFree')) {
      ctx.fillStyle = 'rgba(100,200,255,0.15)';
      ctx.font = 'bold 18px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText('\u2744\uFE0F FROZEN - 40% Power', canvas.width / 2, CUSHION + 20);
    }

    ctx.restore();
  }

  function drawBall(b) {
    const color = BALL_COLORS[b.id];
    const isStripe = b.id >= 9 && b.id <= 15;
    const isCue = b.id === 0;

    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.arc(b.x + 2, b.y + 2, BALL_R, 0, Math.PI * 2);
    ctx.fill();

    if (isStripe) {
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.fill();
      ctx.save();
      ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.clip();
      ctx.fillStyle = color;
      ctx.fillRect(b.x - BALL_R, b.y - BALL_R * 0.5, BALL_R * 2, BALL_R);
      ctx.restore();
    } else {
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.fill();
    }

    // Frozen cue ball tint
    if (isCue && frozenPlayer === currentPlayer && gamePhase === 'aiming') {
      ctx.fillStyle = 'rgba(100,200,255,0.3)';
      ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.fill();
    }

    const hl = ctx.createRadialGradient(b.x - 3, b.y - 3, 1, b.x, b.y, BALL_R);
    hl.addColorStop(0, 'rgba(255,255,255,0.5)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hl;
    ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.fill();

    if (!isCue) {
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.font = 'bold 8px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.id, b.x, b.y + 0.5);
    }

    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2); ctx.stroke();
  }

  // ─── Input ───
  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (e.clientX - rect.left) * sx, y: (e.clientY - rect.top) * sy };
  }

  canvas.addEventListener('mousedown', e => {
    const pos = getMousePos(e);
    mousePos = pos;

    if (gamePhase === 'placing') {
      const cue = balls.find(b => b.id === 0);
      let px = pos.x, py = pos.y;
      const maxX = CUSHION + TABLE_W * 0.25;
      px = Math.max(CUSHION + BALL_R, Math.min(px, maxX));
      py = Math.max(CUSHION + BALL_R, Math.min(py, CUSHION + TABLE_H - BALL_R));
      const overlap = balls.some(b => b.id !== 0 && !b.pocketed && Math.hypot(b.x - px, b.y - py) < BALL_R * 2.5);
      if (!overlap) {
        cue.pocketed = false;
        cue.x = px; cue.y = py;
        placingCue = false;
        gamePhase = 'aiming';
        msgEl.textContent = `Player ${currentPlayer}'s turn`;
        renderPerkBar();
      }
      return;
    }

    if (gamePhase === 'placingFree') {
      const cue = balls.find(b => b.id === 0);
      let px = pos.x, py = pos.y;
      px = Math.max(CUSHION + BALL_R, Math.min(px, CUSHION + TABLE_W - BALL_R));
      py = Math.max(CUSHION + BALL_R, Math.min(py, CUSHION + TABLE_H - BALL_R));
      const overlap = balls.some(b => b.id !== 0 && !b.pocketed && Math.hypot(b.x - px, b.y - py) < BALL_R * 2.5);
      if (!overlap) {
        cue.pocketed = false;
        cue.x = px; cue.y = py;
        gamePhase = 'aiming';
        msgEl.textContent = `Cue ball placed! Player ${currentPlayer}'s turn`;
        renderPerkBar();
      }
      return;
    }

    if (gamePhase === 'aiming') {
      const cue = balls.find(b => b.id === 0);
      const d = Math.hypot(pos.x - cue.x, pos.y - cue.y);
      if (d < BALL_R * 3) {
        aimStart = { x: cue.x, y: cue.y };
        powerBarContainer.style.display = 'block';
      }
    }
  });

  document.addEventListener('mousemove', e => {
    mousePos = getMousePos(e);
    if (aimStart) {
      const dist = Math.hypot(aimStart.x - mousePos.x, aimStart.y - mousePos.y);
      const pct = Math.min(dist / 200, 1) * 100;
      powerBarEl.style.height = pct + '%';
    }
  });

  document.addEventListener('mouseup', e => {
    if (gamePhase === 'aiming' && aimStart) {
      mousePos = getMousePos(e);
      const cue = balls.find(b => b.id === 0);
      const dx = aimStart.x - mousePos.x;
      const dy = aimStart.y - mousePos.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 10) {
        let maxP = MAX_POWER;
        if (activePerk === 'powerSurge') maxP = MAX_POWER * 2;
        if (frozenPlayer === currentPlayer) maxP = MAX_POWER * 0.4;

        const power = Math.min(dist / 200, 1) * maxP;
        const nx = dx / dist, ny = dy / dist;
        cue.vx = nx * power;
        cue.vy = ny * power;
        gamePhase = 'shooting';
        pocketedThisTurn = [];
        cueBallPocketed = false;
        firstContactBall = null;
        msgEl.textContent = '';

        // Clear frozen status after this shot
        if (frozenPlayer === currentPlayer) frozenPlayer = 0;
      }

      aimStart = null;
      powerBarContainer.style.display = 'none';
      powerBarEl.style.height = '0%';
    }
  });

  // ─── Start / Restart ───
  document.getElementById('startBtn').addEventListener('click', startGame);
  overlayEl.querySelector('.btn').addEventListener('click', startGame);

  function startGame() {
    overlayEl.classList.add('hidden');
    rackBalls();
    currentPlayer = 1;
    playerTypes = { 1: null, 2: null };
    playerPerks = { 1: [], 2: [] };
    breakShot = true;
    winner = null;
    activePerk = null;
    frozenPlayer = 0;
    pocketSizeBonus = 0;
    particles = [];
    trailPoints = [];
    screenShake = 0;
    gamePhase = 'aiming';
    msgEl.textContent = 'Break the rack!';
    updateHUD();
    renderPerkBar();
  }

  // ─── Game Loop ───
  function loop() {
    if (gamePhase === 'shooting') {
      for (let i = 0; i < 3; i++) stepPhysics();
      if (!moving()) resolveTurn();
    }
    updateParticles();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
